<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/FluxInterpreter.Test/FluxInterpreter.Test.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FluxInterpreter.Test/FluxInterpreter.Test.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;&#10;        &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#10;        &lt;IsTestProject&gt;true&lt;/IsTestProject&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.0&quot;/&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.8.0&quot;/&gt;&#10;        &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.5.3&quot;/&gt;&#10;        &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.5.3&quot;/&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;Using Include=&quot;Xunit&quot;/&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;ProjectReference Include=&quot;..\FluxInterpreter\FluxInterpreter.csproj&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#13;&#10;&#13;&#10;    &lt;PropertyGroup&gt;&#13;&#10;        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#13;&#10;        &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#13;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#13;&#10;&#13;&#10;        &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#13;&#10;        &lt;IsTestProject&gt;true&lt;/IsTestProject&gt;&#13;&#10;    &lt;/PropertyGroup&gt;&#13;&#10;&#13;&#10;    &lt;ItemGroup&gt;&#13;&#10;        &lt;PackageReference Include=&quot;coverlet.collector&quot; Version=&quot;6.0.0&quot;/&gt;&#13;&#10;        &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.8.0&quot;/&gt;&#13;&#10;        &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.5.3&quot;/&gt;&#13;&#10;        &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.5.3&quot;/&gt;&#13;&#10;    &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;    &lt;ItemGroup&gt;&#13;&#10;        &lt;Using Include=&quot;Xunit&quot;/&gt;&#13;&#10;    &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;    &lt;ItemGroup&gt;&#13;&#10;        &lt;ProjectReference Include=&quot;..\FluxInterpreter\FluxInterpreter.csproj&quot; /&gt;&#13;&#10;    &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FluxInterpreter/Scanner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FluxInterpreter/Scanner.cs" />
              <option name="originalContent" value="namespace FluxInterpreter;&#10;&#10;public class Scanner(string source)&#10;{&#10;    private readonly List&lt;Token&gt; _tokens = [];&#10;    private int _start = 0;&#10;    private int _current = 0;&#10;    private int _line = 1;&#10;&#10;    private static readonly Dictionary&lt;string, TokenType&gt; Keywords = new()&#10;    {&#10;        { &quot;and&quot;, TokenType.And },&#10;        { &quot;class&quot;, TokenType.Class },&#10;        { &quot;else&quot;, TokenType.Else },&#10;        { &quot;false&quot;, TokenType.False },&#10;        { &quot;for&quot;, TokenType.For },&#10;        { &quot;fun&quot;, TokenType.Fun },&#10;        { &quot;if&quot;, TokenType.If },&#10;        { &quot;nil&quot;, TokenType.Nil },&#10;        { &quot;or&quot;, TokenType.Or },&#10;        { &quot;print&quot;, TokenType.Print },&#10;        { &quot;return&quot;, TokenType.Return },&#10;        { &quot;super&quot;, TokenType.Super },&#10;        { &quot;this&quot;, TokenType.This },&#10;        { &quot;true&quot;, TokenType.True },&#10;        { &quot;var&quot;, TokenType.Var },&#10;        { &quot;while&quot;, TokenType.While }&#10;    };&#10;&#10;    public List&lt;Token&gt; ScanTokens()&#10;    {&#10;        while (!IsAtEnd())&#10;        {&#10;            _start = _current;&#10;            ScanToken();&#10;        }&#10;&#10;        _tokens.Add(new Token(TokenType.Eof, &quot;&quot;, null, _line));&#10;        return _tokens;&#10;    }&#10;&#10;    private void ScanToken()&#10;    {&#10;        char c = Advance();&#10;&#10;        switch (c)&#10;        {&#10;            case '(':&#10;                AddToken(TokenType.LeftParen);&#10;                break;&#10;            case ')':&#10;                AddToken(TokenType.RightParen);&#10;                break;&#10;            case '{':&#10;                AddToken(TokenType.LeftBrace);&#10;                break;&#10;            case '}':&#10;                AddToken(TokenType.RightBrace);&#10;                break;&#10;            case ',':&#10;                AddToken(TokenType.Comma);&#10;                break;&#10;            case '.':&#10;                AddToken(TokenType.Dot);&#10;                break;&#10;            case '-':&#10;                AddToken(TokenType.Minus);&#10;                break;&#10;            case '+':&#10;                AddToken(TokenType.Plus);&#10;                break;&#10;            case ';':&#10;                AddToken(TokenType.Semicolon);&#10;                break;&#10;            case '*':&#10;                AddToken(TokenType.Star);&#10;                break;&#10;            case '!':&#10;                AddToken(Match('=') ? TokenType.NegEqual : TokenType.Neg);&#10;                break;&#10;            case '=':&#10;                AddToken(Match('=') ? TokenType.EqualEqual : TokenType.Equal);&#10;                break;&#10;            case '&lt;':&#10;                AddToken(Match('=') ? TokenType.LessEqual : TokenType.Less);&#10;                break;&#10;            case '&gt;':&#10;                AddToken(Match('=') ? TokenType.GreaterEqual : TokenType.Greater);&#10;                break;&#10;            case '/':&#10;                if (Match('/'))&#10;                {&#10;                    while (Peek() != '\n' &amp;&amp; !IsAtEnd()) Advance();&#10;                }&#10;                else&#10;                {&#10;                    AddToken(TokenType.Slash);&#10;                }&#10;&#10;                break;&#10;            case ' ':&#10;            case '\r':&#10;            case '\t': &#10;                break;&#10;            case '\n':&#10;                ++_line;&#10;                break;&#10;            case '&quot;':&#10;                ScanString();&#10;                break;&#10;            default:&#10;                if (IsDigit(c))&#10;                {&#10;                    ScanNumber();&#10;                }&#10;                else if (IsAlpha(c))&#10;                {&#10;                    ScanIdentifier();&#10;                }&#10;                else&#10;                {&#10;                    Flux.Error(_line, $&quot;Unexpected token: {c}&quot;);&#10;                }&#10;                break;&#10;        }&#10;    }&#10;&#10;    private char Advance()&#10;    {&#10;        return source[_current++];&#10;    }&#10;&#10;    private bool Match(char expected)&#10;    {&#10;        if (IsAtEnd()) return false;&#10;        if (source[_current] != expected) return false;&#10;&#10;        _current++;&#10;        return true;&#10;    }&#10;&#10;    private char Peek()&#10;    {&#10;        if (IsAtEnd()) return '\0';&#10;        return source[_current];&#10;    }&#10;&#10;    private void AddToken(TokenType type)&#10;    {&#10;        AddToken(type, null);&#10;    }&#10;&#10;    private void AddToken(TokenType type, object? literal)&#10;    {&#10;        string text = source.Substring(_start, _current - _start);&#10;        _tokens.Add(new Token(type, text, literal, _line));&#10;    }&#10;&#10;    private bool IsAtEnd()&#10;    {&#10;        return _current &gt;= source.Length;&#10;    }&#10;&#10;    private void ScanString()&#10;    {&#10;        while (Peek() != '&quot;' &amp;&amp; !IsAtEnd())&#10;        {&#10;            if (Peek() == '\n') _line++;&#10;            Advance();&#10;        }&#10;&#10;        if (IsAtEnd())&#10;        {&#10;            Flux.Error(_line, &quot;Unterminated string.&quot;);&#10;            return;&#10;        }&#10;&#10;        Advance();&#10;&#10;        string value = source.Substring(_start + 1, _current - _start - 2);&#10;        AddToken(TokenType.String, value);&#10;    }&#10;&#10;    private bool IsDigit(char c)&#10;    {&#10;        return c &gt;= '0' &amp;&amp; c &lt;= '9';&#10;    }&#10;&#10;    private void ScanNumber()&#10;    {&#10;        while (IsDigit(Peek())) Advance();&#10;&#10;        // Look for a fractional part.&#10;        if (Peek() == '.' &amp;&amp; IsDigit(PeekNext()))&#10;        {&#10;            // Consume the &quot;.&quot;&#10;            Advance();&#10;&#10;            while (IsDigit(Peek())) Advance();&#10;        }&#10;&#10;        AddToken(TokenType.Number, double.Parse(source.Substring(_start, _current - _start)));&#10;    }&#10;&#10;    private char PeekNext()&#10;    {&#10;        if (_current + 1 &gt;= source.Length) return '\0';&#10;        return source[_current + 1];&#10;    }&#10;&#10;    private bool IsAlpha(char c)&#10;    {&#10;        return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || c == '_';&#10;    }&#10;&#10;    private void ScanIdentifier()&#10;    {&#10;        while (IsAlphaNumeric(Peek())) Advance();&#10;&#10;        string text = source.Substring(_start, _current - _start);&#10;        TokenType type = Keywords.GetValueOrDefault(text, TokenType.Identifier);&#10;        AddToken(type);&#10;    }&#10;&#10;    private bool IsAlphaNumeric(char c)&#10;    {&#10;        return IsAlpha(c) || IsDigit(c);&#10;    }&#10;}" />
              <option name="updatedContent" value="namespace FluxInterpreter;&#10;&#10;public class Scanner(string source)&#10;{&#10;    private readonly List&lt;Token&gt; _tokens = [];&#10;    private int _start = 0;&#10;    private int _current = 0;&#10;    private int _line = 1;&#10;&#10;    private static readonly Dictionary&lt;string, TokenType&gt; Keywords = new()&#10;    {&#10;        { &quot;and&quot;, TokenType.And },&#10;        { &quot;class&quot;, TokenType.Class },&#10;        { &quot;else&quot;, TokenType.Else },&#10;        { &quot;false&quot;, TokenType.False },&#10;        { &quot;for&quot;, TokenType.For },&#10;        { &quot;fun&quot;, TokenType.Fun },&#10;        { &quot;if&quot;, TokenType.If },&#10;        { &quot;nil&quot;, TokenType.Nil },&#10;        { &quot;or&quot;, TokenType.Or },&#10;        { &quot;print&quot;, TokenType.Print },&#10;        { &quot;return&quot;, TokenType.Return },&#10;        { &quot;super&quot;, TokenType.Super },&#10;        { &quot;this&quot;, TokenType.This },&#10;        { &quot;true&quot;, TokenType.True },&#10;        { &quot;var&quot;, TokenType.Var },&#10;        { &quot;while&quot;, TokenType.While }&#10;    };&#10;&#10;    public List&lt;Token&gt; ScanTokens()&#10;    {&#10;        while (!IsAtEnd())&#10;        {&#10;            _start = _current;&#10;            ScanToken();&#10;        }&#10;&#10;        _tokens.Add(new Token(TokenType.Eof, &quot;&quot;, null, _line));&#10;        return _tokens;&#10;    }&#10;&#10;    private void ScanToken()&#10;    {&#10;        char c = Advance();&#10;&#10;        switch (c)&#10;        {&#10;            case '(':&#10;                AddToken(TokenType.LeftParen);&#10;                break;&#10;            case ')':&#10;                AddToken(TokenType.RightParen);&#10;                break;&#10;            case '{':&#10;                AddToken(TokenType.LeftBrace);&#10;                break;&#10;            case '}':&#10;                AddToken(TokenType.RightBrace);&#10;                break;&#10;            case ',':&#10;                AddToken(TokenType.Comma);&#10;                break;&#10;            case '.':&#10;                AddToken(TokenType.Dot);&#10;                break;&#10;            case '-':&#10;                AddToken(TokenType.Minus);&#10;                break;&#10;            case '+':&#10;                AddToken(TokenType.Plus);&#10;                break;&#10;            case ';':&#10;                AddToken(TokenType.Semicolon);&#10;                break;&#10;            case '*':&#10;                AddToken(TokenType.Star);&#10;                break;&#10;            case '!':&#10;                AddToken(Match('=') ? TokenType.NegEqual : TokenType.Neg);&#10;                break;&#10;            case '=':&#10;                AddToken(Match('=') ? TokenType.EqualEqual : TokenType.Equal);&#10;                break;&#10;            case '&lt;':&#10;                AddToken(Match('=') ? TokenType.LessEqual : TokenType.Less);&#10;                break;&#10;            case '&gt;':&#10;                AddToken(Match('=') ? TokenType.GreaterEqual : TokenType.Greater);&#10;                break;&#10;            case '/':&#10;                if (Match('/'))&#10;                {&#10;                    while (Peek() != '\n' &amp;&amp; !IsAtEnd()) Advance();&#10;                }&#10;                else&#10;                {&#10;                    AddToken(TokenType.Slash);&#10;                }&#10;&#10;                break;&#10;            case ' ':&#10;            case '\r':&#10;            case '\t': &#10;                break;&#10;            case '\n':&#10;                ++_line;&#10;                break;&#10;            case '&quot;':&#10;                ScanString();&#10;                break;&#10;            default:&#10;                if (IsDigit(c))&#10;                {&#10;                    ScanNumber();&#10;                }&#10;                else if (IsAlpha(c))&#10;                {&#10;                    ScanIdentifier();&#10;                }&#10;                else&#10;                {&#10;                    Flux.Error(_line, $&quot;Unexpected token: {c}&quot;);&#10;                }&#10;                break;&#10;        }&#10;    }&#10;&#10;    private char Advance()&#10;    {&#10;        return source[_current++];&#10;    }&#10;&#10;    private bool Match(char expected)&#10;    {&#10;        if (IsAtEnd()) return false;&#10;        if (source[_current] != expected) return false;&#10;&#10;        _current++;&#10;        return true;&#10;    }&#10;&#10;    private char Peek()&#10;    {&#10;        if (IsAtEnd()) return '\0';&#10;        return source[_current];&#10;    }&#10;&#10;    private void AddToken(TokenType type)&#10;    {&#10;        AddToken(type, null);&#10;    }&#10;&#10;    private void AddToken(TokenType type, object? literal)&#10;    {&#10;        string text = source.Substring(_start, _current - _start);&#10;        _tokens.Add(new Token(type, text, literal, _line));&#10;    }&#10;&#10;    private bool IsAtEnd()&#10;    {&#10;        return _current &gt;= source.Length;&#10;    }&#10;&#10;    private void ScanString()&#10;    {&#10;        while (Peek() != '&quot;' &amp;&amp; !IsAtEnd())&#10;        {&#10;            if (Peek() == '\n') _line++;&#10;            Advance();&#10;        }&#10;&#10;        if (IsAtEnd())&#10;        {&#10;            Flux.Error(_line, &quot;Unterminated string.&quot;);&#10;            return;&#10;        }&#10;&#10;        Advance();&#10;&#10;        string value = source.Substring(_start + 1, _current - _start - 2);&#10;        AddToken(TokenType.String, value);&#10;    }&#10;&#10;    private bool IsDigit(char c)&#10;    {&#10;        return c &gt;= '0' &amp;&amp; c &lt;= '9';&#10;    }&#10;&#10;    private void ScanNumber()&#10;    {&#10;        while (IsDigit(Peek())) Advance();&#10;&#10;        // Look for a fractional part.&#10;        if (Peek() == '.' &amp;&amp; IsDigit(PeekNext()))&#10;        {&#10;            // Consume the &quot;.&quot;&#10;            Advance();&#10;&#10;            while (IsDigit(Peek())) Advance();&#10;        }&#10;&#10;        AddToken(TokenType.Number, double.Parse(source.Substring(_start, _current - _start)));&#10;    }&#10;&#10;    private char PeekNext()&#10;    {&#10;        if (_current + 1 &gt;= source.Length) return '\0';&#10;        return source[_current + 1];&#10;    }&#10;&#10;    private bool IsAlpha(char c)&#10;    {&#10;        return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || c == '_';&#10;    }&#10;&#10;    private void ScanIdentifier()&#10;    {&#10;        while (IsAlphaNumeric(Peek())) Advance();&#10;&#10;        string text = source.Substring(_start, _current - _start);&#10;        TokenType type = Keywords.GetValueOrDefault(text, TokenType.Identifier);&#10;        AddToken(type);&#10;    }&#10;&#10;    private bool IsAlphaNumeric(char c)&#10;    {&#10;        return IsAlpha(c) || IsDigit(c);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>